<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Konarak Collage</title>

<style>
    body {
        margin: 0;
        padding: 0;
        background: #f28c2b;
        font-family: Arial, sans-serif;
    }

    .box {
        max-width: 900px;
        margin: 20px auto;
        background: #f28c2b;
        padding: 15px;
        border-radius: 10px;
    }

    /* Preview grid (unchanged behavior) */
    #preview {
        display: grid;
        grid-template-columns: repeat(2,1fr);
        grid-auto-rows: auto;
        gap: 10px;
        margin-top: 15px;
    }

    #preview img {
        width: 100%;
        height: 100%;
        object-fit: contain;
        background: #00000020;
        border: 8px solid #f28c2b;
        border-radius: 6px;
    }

    button {
        width: 100%;
        padding: 14px;
        margin-top: 12px;
        background: #fff;
        border: none;
        border-radius: 8px;
        color: #f28c2b;
        font-weight: bold;
        font-size: 17px;
        cursor: pointer;
    }

    #download {
        display:none;
        width: 100%;
        margin-top: 15px;
        padding: 14px;
        background: #333;
        color: #fff;
        text-align:center;
        text-decoration:none;
        border-radius:8px;
        font-size: 17px;
    }

    #status {
        text-align:center;
        font-size:16px;
        font-weight:bold;
        margin-top:10px;
        color:#fff;
        display:none;
    }
</style>
</head>

<body>

<div class="box">
    <input id="files" type="file" accept="image/*" multiple>
    <div id="preview"></div>

    <div id="status"></div>

    <button id="make">Generate Collage</button>
    <a id="download" download="Konarak.jpg">Download Final Image</a>
</div>

<canvas id="canvas" style="display:none"></canvas>

<script>
let selected = [];
let loadedImages = [];

const filesInput = document.getElementById("files");
const preview = document.getElementById("preview");
const makeBtn = document.getElementById("make");
const downloadBtn = document.getElementById("download");
const canvas = document.getElementById("canvas");
const statusBox = document.getElementById("status");
const ctx = canvas.getContext("2d");

/*  
  Masonry rules:
  - Small image → span = 1 (1×1)
  - Wide image  → span = 2 (2×1)
  - Large image → span = 2 with height multiplier 2 (2×2)
  We'll pack into 2 columns. To reduce gaps we place larger spans first.
*/

// Preview thumbnails (unchanged visual behavior)
filesInput.addEventListener("change", () => {
    preview.innerHTML = "";
    selected = Array.from(filesInput.files);
    loadedImages = [];
    statusBox.style.display = "none";

    selected.forEach(file => {
        const img = new Image();
        img.src = URL.createObjectURL(file);

        img.onload = () => {
            let spanW = 1;
            let spanH = 1;
            const w = img.width;
            const h = img.height;
            const ratio = w / h;

            // Large images
            if (w > 2500 || h > 2500 || w * h > 5_000_000) {
                spanW = 2;
                spanH = 2;
            }
            // Wide images
            else if (ratio > 1.6) {
                spanW = 2;
                spanH = 1;
            }

            img.style.gridColumn = "span " + spanW;
            img.style.gridRow = "span " + spanH;

            preview.appendChild(img);
        };
    });

    downloadBtn.style.display = "none";
});

// Utility: load file to Image object
function loadImage(file) {
    return new Promise(resolve => {
        const reader = new FileReader();
        reader.onload = e => {
            const img = new Image();
            img.onload = () => resolve(img);
            img.src = e.target.result;
        };
        reader.readAsDataURL(file);
    });
}

// Preload all images
async function preloadAll() {
    statusBox.style.display = "block";
    statusBox.innerText = "Preparing images...";

    loadedImages = [];

    for (let i = 0; i < selected.length; i++) {
        statusBox.innerText = `Loading ${i+1}/${selected.length}...`;
        const img = await loadImage(selected[i]);
        loadedImages.push(img);
    }

    statusBox.innerText = "All images loaded!";
    await new Promise(r => setTimeout(r, 300)); 
    statusBox.style.display = "none";
}

// Determine classification for an image
function classifyImage(img) {
    const w = img.width;
    const h = img.height;
    const ratio = w / h;

    // Large image -> 2x2
    if (w > 2500 || h > 2500 || w * h > 5_000_000) {
        return { span: 2, hMul: 2 };
    }
    // Wide -> spans 2 columns horizontally
    if (ratio > 1.6) {
        return { span: 2, hMul: 1 };
    }
    // Small / default -> single cell
    return { span: 1, hMul: 1 };
}

// Main generate button: build masonry layout, then draw
makeBtn.addEventListener("click", async () => {
    if (selected.length === 0) {
        alert("Upload photos first.");
        return;
    }

    makeBtn.innerText = "Preparing...";
    makeBtn.disabled = true;

    await preloadAll();

    makeBtn.innerText = "Generating...";

    // Canvas base width; we keep same full-width as before (2500)
    const W = 2500;
    const footerH = 180;
    const border = 40; // outer margin
    const gap = 10; // gap between column cells
    const thick = 20; // stroke thickness around images

    // Usable area for images width
    const usableW = W - border * 2;
    const cols = 2;
    const colW = (usableW - gap) / cols; // width of a single column

    // Build items array with classification and computed target widths/heights
    const items = loadedImages.map((img, idx) => {
        const cls = classifyImage(img);
        const span = cls.span; // 1 or 2
        const hMul = cls.hMul; // 1 or 2 (large images hMul=2)

        // spanWidth includes gap between columns when span==2 (colW*2 + gap)
        const spanWidth = (span === 1) ? colW : (colW * 2 + gap);

        // Calculate display height when fit to spanWidth preserving aspect ratio
        let displayH = img.height * (spanWidth / img.width);

        // If large (hMul === 2) increase height to occupy two row heights (approx)
        // We'll treat hMul as multiplier of the image's computed height.
        displayH = displayH * hMul;

        return {
            img,
            idx,
            span,
            hMul,
            spanWidth,
            displayH,
            displayW: spanWidth
        };
    });

    // Sort items: place large (hMul>1) then span=2 then span=1 to reduce gaps
    items.sort((a, b) => {
        // primary: hMul desc (2 first), secondary: span desc (2 before 1), tertiary: area desc
        if (b.hMul !== a.hMul) return b.hMul - a.hMul;
        if (b.span !== a.span) return b.span - a.span;
        const areaA = a.img.width * a.img.height;
        const areaB = b.img.width * b.img.height;
        return areaB - areaA;
    });

    // Column heights tracking
    const colHeights = new Array(cols).fill(0);

    // We'll store placements: x,y,width,height,img
    const placements = [];

    // Place each item
    for (const it of items) {
        if (it.span === 1) {
            // place into column with minimum height
            let colIndex = 0;
            let minH = colHeights[0];
            for (let c = 1; c < cols; c++) {
                if (colHeights[c] < minH) {
                    minH = colHeights[c];
                    colIndex = c;
                }
            }

            const x = border + colIndex * (colW + gap);
            const y = border + colHeights[colIndex];

            placements.push({
                img: it.img,
                x,
                y,
                w: it.displayW,
                h: it.displayH,
                span: 1
            });

            // update that column height
            colHeights[colIndex] = colHeights[colIndex] + it.displayH + gap;
        } else {
            // span === 2 (covers both columns)
            // we must place at y that is >= both column heights (so no overlap)
            const y = border + Math.max(...colHeights);
            const x = border; // starts at leftmost

            placements.push({
                img: it.img,
                x,
                y,
                w: it.displayW,
                h: it.displayH,
                span: 2
            });

            // update both column heights to new level (y - border + height)
            const newColH = (y - border) + it.displayH + gap;
            for (let c = 0; c < cols; c++) colHeights[c] = newColH;
        }
    }

    // Compute final canvas height (tight fit)
    const contentH = Math.max(...colHeights) + border; // bottom margin
    const finalCanvasH = Math.ceil(contentH + footerH);

    // Set canvas size now (width fixed, height dynamic)
    canvas.width = W;
    canvas.height = finalCanvasH;

    // Draw background
    ctx.fillStyle = "#f28c2b";
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw all placements
    for (const p of placements) {
        // Clip to a rectangle area and draw image centered within it,
        // keeping full image visible (no cropping). We'll fit by width (we designed width-based sizing),
        // but if the image's height is less than the allocated height, center it vertically.
        const destW = Math.round(p.w);
        const destH = Math.round(p.h);

        // Calculate scale to fit inside the slot (fit by width; ensure not to exceed height)
        const scale = Math.min(destW / p.img.width, destH / p.img.height);
        const drawW = p.img.width * scale;
        const drawH = p.img.height * scale;

        const drawX = Math.round(p.x + (destW - drawW) / 2);
        const drawY = Math.round(p.y + (destH - drawH) / 2);

        ctx.save();
        ctx.beginPath();
        ctx.rect(p.x, p.y, destW, destH);
        ctx.clip();
        ctx.drawImage(p.img, drawX, drawY, drawW, drawH);
        ctx.restore();

        // Draw stroke around the allocated cell
        ctx.strokeStyle = "#d86f1b";
        ctx.lineWidth = thick;
        ctx.strokeRect(p.x + thick/2, p.y + thick/2, destW - thick, destH - thick);
    }

    // Footer
    const H = canvas.height;
    ctx.fillStyle = "#333";
    ctx.fillRect(0, H - footerH, canvas.width, footerH);

    ctx.fillStyle = "#fff";
    ctx.textAlign = "center";
    ctx.font = "bold 50px Arial";
    ctx.fillText("Konarak Food & Beverages", canvas.width / 2, H - footerH / 2 - 10);

    ctx.font = "30px Arial";
    ctx.fillText(new Date().toLocaleString(), canvas.width / 2, H - footerH / 2 + 40);

    // Export as JPEG, keeping the same size limit routine
    let q = 0.92;
    let output = canvas.toDataURL("image/jpeg", q);

    while (output.length / 1024 / 1024 > 5 && q > 0.3) {
        q -= 0.05;
        output = canvas.toDataURL("image/jpeg", q);
    }

    downloadBtn.href = output;
    downloadBtn.style.display = "block";

    makeBtn.innerText = "Generate Collage";
    makeBtn.disabled = false;
});
</script>

</body>
</html>
